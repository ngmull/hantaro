if(length(missing)>0) {
message("dbarts auto-dropped this variable(s). You will probably want to remove it")
message(paste(missing,collapse = ' '), ' \n')
}
if(length(missing)>0) {
missing.df <- data.frame(names = missing, varimps = 0)
var.df <- rbind(var.df, missing.df)
}
var.df$names <- factor(var.df$names)
var.df <- transform(var.df, names = reorder(names,
-varimps))
if(plots==TRUE){
#g1 <- ggplot2::ggplot(var.df, aes(y=varimps, x=names)) +
#  geom_bar(stat="identity", color="black") +
#  theme(axis.text.x = element_text(angle = 45)) +
#  ylab("Relative importance") + theme_bluewhite()
#print(g1)
rel <- model$varcount/rowSums(model$varcount)
colnames(rel) <- names
rel %>% data.frame() %>% gather() %>%
group_by(key) %>%
summarise(mean = mean(value),
sd = sd(value, na.rm = TRUE)) %>%
transform(Var = reorder(key, mean)) %>%
ggplot(aes(x = Var, y = mean)) +
geom_pointrange(aes(y = mean, x = Var, ymin = mean-sd, ymax = mean+sd),
color="#00AFDD") +
xlab(NULL) + ylab("Variable importance") + coord_flip() +
theme_bw() + theme(legend.position = "none",
axis.title.x = element_text(size=rel(1.3), vjust = -0.8),
axis.text.y = element_text(size=rel(1.4)),
plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_line(color='grey',
linetype='dashed')) -> p
print(p)
}
return(var.df)
}
nwdp <- read_csv('C:/Users/cjcar/Desktop/plague data download 1May2019.csv')
library(tidyverse)
nwdp <- read_csv('C:/Users/cjcar/Desktop/plague data download 1May2019.csv')
ncp <- nc_open("G:/Shared drives/MALARIA_AFRICA/Bias-Corrected_data/precipitation/ssp5-8.5/BC_pr_Amon_BCC-CSM2-MR_ssp585_r1i1p1f1_gn_201501-210012_lonlat.nc")
nct <- nc_open("G:/Shared drives/MALARIA_AFRICA/Bias-Corrected_data/temperature/ssp5-8.5/BC_tas_Amon_BCC-CSM2-MR_ssp585_r1i1p1f1_gn_201501-210012_lonlat.nc")
outname <- 'BCC-CSM2-rcp85'
source("C:/Users/cjcar/Dropbox/MalariaAttribution/Scripts/Netcdf_Wrangling_Future.R")
rm(list=ls())
library(ncdf4)
library(raster)
library(rgdal)
library(sp)
library(tidyr)
library(velox)
ncp <- nc_open("G:/Shared drives/MALARIA_AFRICA/Bias-Corrected_data/precipitation/ssp5-8.5/BC_pr_Amon_BCC-CSM2-MR_ssp585_r1i1p1f1_gn_201501-210012_lonlat.nc")
ncp
tasmax_name <- 'D:/DECIMALS/GLENS/control_run1_TREFHTMX_20100101-20990630_1deg.nc'
tasmin_name <- 'D:/DECIMALS/GLENS/control_run1_TREFHTMN_20100101-20990630_1deg.nc'
precip_name <- 'D:/DECIMALS/GLENS/control_run1_pr_201001-209906_1deg.nc'
# Metadata
ncmeta::nc_atts(tasmax_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(tasmin_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(precip_name, "time") %>% tidyr::unnest(cols = c(value))
# Extract the time signatures - D0 GLENS / D2 G3
tidync(tasmax_name) %>% activate("D0") %>% hyper_array() -> times1
tidync(tasmin_name) %>% activate("D0") %>% hyper_array() -> times2
tidync(precip_name) %>% activate("D0") %>% hyper_array() -> times3
# Basic summary of info
# activate() - D2 for G3, D0 for GLENS
# Julian day table: http://uop.whoi.edu/UOPinstruments/frodo/aer/julian-day-table.html
library(tidyverse)
library(tidync)
tasmax_name <- 'D:/DECIMALS/GLENS/control_run1_TREFHTMX_20100101-20990630_1deg.nc'
tasmin_name <- 'D:/DECIMALS/GLENS/control_run1_TREFHTMN_20100101-20990630_1deg.nc'
precip_name <- 'D:/DECIMALS/GLENS/control_run1_pr_201001-209906_1deg.nc'
# Metadata
ncmeta::nc_atts(tasmax_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(tasmin_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(precip_name, "time") %>% tidyr::unnest(cols = c(value))
# Extract the time signatures - D0 GLENS / D2 G3
tidync(tasmax_name) %>% activate("D0") %>% hyper_array() -> times1
tidync(tasmin_name) %>% activate("D0") %>% hyper_array() -> times2
tidync(precip_name) %>% activate("D0") %>% hyper_array() -> times3
# Visual checks for any gaps
plot(times1$time)
plot(times2$time)
plot(times3$time)
# Check values for increment (1:5), which is sometimes different for ppt, and range
range(times1)
times1$time[1:5]
range(times2)
# Reported started date: 01-01-2010
# Reported end date (temp): 08-11-2098
# Reported end date (ppt): 06-2100
# Units: days since 2010-01-01 00:00:00
# Daily increment (temp): +1
# Starting temp: 0
# Daily increment (ppt): ROTATING SEQUENCE: 29.5 29.5 30.5 30.5 30.5 30.5 31.0 30.5 30.5 30.5 30.5 31.0
# Starting ppt: 15
# Days in a year: 365
# ** Major discrepancies: none?
tasmax_name <- 'D:/DECIMALS/GLENS/control_run2_TREFHTMX_20100101-20980811_1deg.nc'
tasmin_name <- 'D:/DECIMALS/GLENS/control_run2_TREFHTMN_20100101-20980811_1deg.nc'
precip_name <- 'D:/DECIMALS/GLENS/control_run2_pr_201001-210006_1deg.nc'
# Metadata
ncmeta::nc_atts(tasmax_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(tasmin_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(precip_name, "time") %>% tidyr::unnest(cols = c(value))
# Extract the time signatures
tidync(tasmax_name) %>% activate("D0") %>% hyper_array() -> times1
tidync(tasmin_name) %>% activate("D0") %>% hyper_array() -> times2
tidync(precip_name) %>% activate("D0") %>% hyper_array() -> times3
# Visual checks for any gaps
plot(times1$time)
plot(times2$time)
plot(times3$time)
tasmax_name <- 'D:/DECIMALS/GLENS/control_run3_TREFHTMX_20100101-21000630_1deg.nc'
tasmin_name <- 'D:/DECIMALS/GLENS/control_run3_TREFHTMN_20100101-21000630_1deg.nc'
precip_name <- 'D:/DECIMALS/GLENS/control_run3_pr_201001-209808_1deg.nc'
# Metadata
ncmeta::nc_atts(tasmax_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(tasmin_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(precip_name, "time") %>% tidyr::unnest(cols = c(value))
# Extract the time signatures
tidync(tasmax_name) %>% activate("D0") %>% hyper_array() -> times1
tidync(tasmin_name) %>% activate("D0") %>% hyper_array() -> times2
tidync(precip_name) %>% activate("D0") %>% hyper_array() -> times3
# Visual checks for any gaps
plot(times1$time)
plot(times2$time)
plot(times3$time)
tasmax_name <- 'D:/DECIMALS/GLENS/feedback_run1_TREFHTMX_20200101-20991231_1deg.nc'
tasmin_name <- 'D:/DECIMALS/GLENS/feedback_run1_TREFHTMN_202020200101-20991231_1deg.nc'
precip_name <- 'D:/DECIMALS/GLENS/feedback_run1_pr_20200101-20991231_1deg.nc'
# precip_name <- "C:/Users/cjcar/Downloads/feedback_run1_pr_20200101-20991231.nc"
# Metadata
ncmeta::nc_atts(tasmax_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(tasmin_name, "time") %>% tidyr::unnest(cols = c(value))
ncmeta::nc_atts(precip_name, "time") %>% tidyr::unnest(cols = c(value))
# Extract the time signatures - D0 GLENS / D2 G3
tidync(tasmax_name) %>% activate("D0") %>% hyper_array() -> times1
tidync(tasmin_name) %>% activate("D0") %>% hyper_array() -> times2
tidync(precip_name) %>% activate("D0") %>% hyper_array() -> times3
# Visual checks for any gaps
plot(times1$time)
stablename <- 'Africa_stable_GL_2'
library(tidync)
library(raster)
library(rgdal)
library(sf)
################## THIS SETS THE RIGHT PARTS RUNNING
unstablename <- 'Africa_unstable_GL_2'
stablename <- 'Africa_stable_GL_2'
tasmax_name <- 'D:/DECIMALS/GLENS/feedback_run2_TREFHTMX_20200101-20991231_1deg.nc'
tasmin_name <- 'D:/DECIMALS/GLENS/feedback_run2_TREFHTMN_202020200101-20991231_1deg.nc'
precip_name <- 'D:/DECIMALS/GLENS/feedback_run2_pr_20200101-20991231_1deg.nc'
# Load in some functions
c2k <- 273.15
tmax1 <- 34 + c2k
tmin1 <- 17 + c2k
fastestize <- function(poly,raster) {
require(fasterize)
y <- disaggregate(raster,10)
p <- st_as_sf(poly)
z <- fasterize(p,y)
x <- raster::aggregate(z,10,fun='sum')/100
return(x)
}
raster_tibble <- function(df) {
rasterFromXYZ(df[,c(2,3,1)])
}
# D2 for G3, D0 for GLENS
tidync(tasmax_name) %>% activate("D0") %>% hyper_array() -> times1; plot(times1$time)
tidync(tasmin_name) %>% activate("D0") %>% hyper_array() -> times2; plot(times2$time)
range(times1)
range(times2)
### CODE FOR 2020 IS BORKEN (THESE START 2020 FIX IN AM)
# FUNCTIONS
#lonrange <- c(144, 247)
#latrange <- c(-46, 47)
SHAPEFILE <- readOGR(layer="GBD-Adjusted",dsn='D:/DECIMALS/Regions')
SSA <- c('Sub-Saharan Africa (East)',
'Sub-Saharan Africa (Central)',
'Sub-Saharan Africa (Southern)',
'Sub-Saharan Africa (West)')
REGIONS <- SHAPEFILE[SHAPEFILE$Region %in% SSA,]
ncmeta::nc_atts(tasmax_name, "time") %>% tidyr::unnest(cols = c(value))
## Visualise statistical and spatial distributions
## (advanced!)
library(maps)
vars <- as.data.frame(state.x77)
StateName <- tolower(state.name)
form <- StateName ~ Population + Income + Illiteracy +
`Life Exp` + Murder + `HS Grad` + Frost + sqrt(Area)
## construct independent maps of each variable
statemap <- map("state", plot = FALSE, fill = TRUE)
colkey <- draw.colorkey(list(col = heat.colors(100), at = 0:100,
labels = list(labels = c("min","max"), at = c(0,100))))
panel.mapplot.each <- function(x, breaks, ...)
panel.mapplot(x = x, breaks = quantile(x), ...)
vmaps <- mapplot(form, vars, map = statemap, colramp = heat.colors,
panel = panel.mapplot.each, colorkey = FALSE,
legend = list(right = list(fun = colkey)), xlab = NULL)
## construct independent densityplots of each variable
vdens <- densityplot(form[-2], vars, outer = TRUE, cut = 0,
scales = list(relation = "free"), ylim = c(0, NA),
cex = 0.5, ref = TRUE) +
layer(panel.axis("top", half = FALSE, text.cex = 0.7))
## combine panels from both plots
combo <- c(vmaps, vdens)
## rearrange in pairs
n <- length(vars)
npairs <- rep(1:n, each = 2) + c(0, n)
update(combo[npairs], scales = list(draw = FALSE),
layout = c(4, 4), between = list(x = c(0, 0.5), y = 0.5))
# }
## Combine different types of plots.
c(wireframe(volcano), contourplot(volcano))
## Merging levelplot with xyplot
levObj <- levelplot(prop.table(WorldPhones, 1) * 100)
xyObj <- xyplot(Phones ~ Year, data.frame(Phones = rowSums(WorldPhones),
Year = row.names(WorldPhones)), type="b", ylim = c(0, 150000))
## NOTE: prepanel.levelplot (from first object) is used for entire plot.
cObj <- c(levObj, xyObj, layout = 1:2)
update(cObj, scales = list(y = list(rot = 0)),
ylab = c("proportional distribution", "number of phones"))
## Combine two xyplots.
sepals <- xyplot(Sepal.Length ~ Sepal.Width, iris, groups = Species,
xlab = "Width", ylab = "Height")
petals <- xyplot(Petal.Length ~ Petal.Width, iris, groups = Species)
c(Sepals = sepals, Petals = petals)
## Force same scales (re-calculate panel limits from merged data):
c(Sepals = sepals, Petals = petals, x.same = TRUE, y.same = TRUE)
## Or - create xyplots from a list of formulas
xyplot.list(list(Sepals = Sepal.Length ~ Sepal.Width,
Petals = Petal.Length ~ Petal.Width),
data = iris, groups = Species, x.same = TRUE,
xlab = "Width", ylab = "Height")
## Create histograms from a list of objects, and merge them.
xyplot.list(iris, FUN = histogram)
## Create cumulative distribution plots from a list of objects
xyplot.list(iris[1:4], FUN = qqmath, groups = iris$Species,
auto.key = TRUE)
## Display a table as both frequencies and proportions:
data(postdoc)
## remove last row (containing totals)
postdoc <- postdoc[1:(nrow(postdoc)-1),]
pdprops <- barchart(prop.table(postdoc, margin = 1),
auto.key = list(adj = 1))
pdmargin <- barchart(margin.table(postdoc, 1))
pdboth <- c(pdprops, pdmargin)
update(pdboth, xlab = c("Proportion", "Freq"))
## Conditioned 'quakes' plot combined with histogram.
qua <- xyplot(lat ~ long | equal.count(depth, 3), quakes,
aspect = "iso", pch = ".", cex = 2, xlab = NULL, ylab = NULL)
qua <- c(qua, depth = histogram(quakes$depth), layout = c(4, 1))
## suppress scales on the first 3 panels
update(qua, scales = list(at = list(NULL, NULL, NULL, NA),
y = list(draw = FALSE)))
## Demonstrate merging of legends and par.settings.
## Note that par.settings can conflict, thus need col.line=...
mypoints <-
xyplot(1:10 ~ 1:10, groups = factor(rep(1:2, each = 5)),
par.settings = simpleTheme(pch = 16), auto.key = TRUE)
mylines <-
xyplot(1:10 ~ 1:10, groups = factor(rep(1:5, each = 2)),
type = "l", par.settings = simpleTheme(col.line = 1:5),
auto.key = list(lines = TRUE, points = FALSE, columns = 5))
c(mypoints, mylines)
library(lattice)
library(maps)
vars <- as.data.frame(state.x77)
StateName <- tolower(state.name)
form <- StateName ~ Population + Income + Illiteracy +
`Life Exp` + Murder + `HS Grad` + Frost + sqrt(Area)
## construct independent maps of each variable
statemap <- map("state", plot = FALSE, fill = TRUE)
colkey <- draw.colorkey(list(col = heat.colors(100), at = 0:100,
labels = list(labels = c("min","max"), at = c(0,100))))
panel.mapplot.each <- function(x, breaks, ...)
panel.mapplot(x = x, breaks = quantile(x), ...)
vmaps <- mapplot(form, vars, map = statemap, colramp = heat.colors,
panel = panel.mapplot.each, colorkey = FALSE,
legend = list(right = list(fun = colkey)), xlab = NULL)
## construct independent densityplots of each variable
vdens <- densityplot(form[-2], vars, outer = TRUE, cut = 0,
scales = list(relation = "free"), ylim = c(0, NA),
cex = 0.5, ref = TRUE) +
layer(panel.axis("top", half = FALSE, text.cex = 0.7))
## combine panels from both plots
combo <- c(vmaps, vdens)
## rearrange in pairs
n <- length(vars)
npairs <- rep(1:n, each = 2) + c(0, n)
update(combo[npairs], scales = list(draw = FALSE),
layout = c(4, 4), between = list(x = c(0, 0.5), y = 0.5))
library(tidyverse)
edge <- read_csv("C:/Users/cjcar/Downloads/edgelist.csv")
beta <- read_csv("~/Github/Fresnel/BinaryWebsite.csv")
beta
edge
edge %>% filter(virus == 'Betacoronavirus') %>% pull(host) -> srabcv
beta %>% filter(Sp %in% srabcv)
beta %>% filter(Sp %in% srabcv) %>% View()
beta %>% filter(Sp %in% srabcv) %>% select(Sp, `Training data`, `New data`, Ensemble, Trait.1)
edge %>% filter(srabcv %in% beta$Sp)
edge
edge %>% filter(virus == 'Betacoronavirus', host %in% beta$Sp)
beta %>% filter(Sp %in% srabcv) %>% select(Sp, `Training data`, `New data`, Ensemble, Trait.1) -> data1
edge %>% filter(virus == 'Betacoronavirus', host %in% beta$Sp) -> data2
edge %>% filter(virus == 'Betacoronavirus', host %in% beta$Sp) %>% select(-virus) -> data2
edge %>% filter(virus == 'Betacoronavirus', host %in% beta$Sp) %>% select(-virus) %>%
rename(Sp = host) -> data2
left_join(beta, edge)
left_join(data1, data2)
library(classInt)
library(tidyverse)
library(raster)
library(rgdal)
library(dismo)
library(XML)
library(maps)
library(sp)
library(velox)
setwd("~/Github/hantaro")
set.seed(12345)
# Read in the data
pred <- read_csv("./data/clean files/hantaro predictions.csv")
# 1. Threshold the results
library(PresenceAbsence)
t.pcr <- optimal.thresholds(data.frame(pred[,c('treename','PCR','pred_pcr')]),
threshold = 10001,
opt.methods = 10,
req.sens = 0.9,
na.rm = TRUE)
t.comp <- optimal.thresholds(data.frame(pred[,c('treename','competence','pred_comp')]),
threshold = 10001,
opt.methods = 10,
req.sens = 0.9,
na.rm = TRUE)
# Threshold the results to binary outputs
pred %>%
mutate(bin_comp = (pred_comp > t.comp$pred_comp),
bin_pcr = (pred_pcr) > t.pcr$pred_pcr) -> pred
# How many predicted undiscovered hosts by PCR?
table(pred$pred_pcr[pred$PCR==0] > t.pcr$pred_pcr)
# How many predicted undiscovered hosts by competence
table(pred$pred_comp[pred$competence==0] > t.comp$pred_comp)
# Do the predicted competence hosts overlap with PCR
pred %>% filter(competence==0, pred_comp > t.comp$pred_comp)
# Pull out the relevant lists
pred %>% filter(competence==1) %>% pull(treename) %>% gsub("_"," ",.) -> known.comp
pred %>% filter(PCR==1) %>% pull(treename) %>% gsub("_"," ",.) -> known.pcr
pred %>% filter(bin_comp==1) %>% pull(treename) %>% gsub("_"," ",.) -> pred.comp
pred %>% filter(bin_pcr==1) %>% pull(treename) %>% gsub("_"," ",.) -> pred.pcr
# 2. Let's make some maps?
library(fasterize)
library(rgdal)
library(raster)
library(sf)
iucn <- st_read(dsn = "C:/Users/cjcar/Dropbox/HowManyHelminths2019", layer='TERRESTRIAL_MAMMALS')
r <- disaggregate(getData("worldclim",var="alt",res=2.5)*0,2) # Make a blank raster
# Create four layers
iucn.1 <- iucn[iucn$binomial %in% known.comp,]
iucn.2 <- iucn[iucn$binomial %in% known.pcr,]
iucn.3 <- iucn[iucn$binomial %in% pred.comp,]
iucn.4 <- iucn[iucn$binomial %in% pred.pcr,]
map.knc <- (fasterize(iucn.1, r, fun="sum"))
map.knp <- (fasterize(iucn.2, r, fun="sum"))
map.prc <- (fasterize(iucn.3, r, fun="sum"))
map.prp <- (fasterize(iucn.4, r, fun="sum"))
fix <- function(x) {sum(x,r,na.rm=TRUE)+r} # This adds zeros for the continental area
map.knc <- fix(map.knc)
map.knp <- fix(map.knp)
map.prc <- fix(map.prc)
map.prp <- fix(map.prp)
raster::stack(map.knp, map.knc, map.prp, map.prc) %>%
crop(c(-170,-25,-90,90)) %>%
raster::trim() -> maps
names(maps) <- c('KnownPCR', 'KnownComp', 'PredPCR', 'PredComp')
# Generate the actual visualization
library(rasterVis)
library(RColorBrewer)
mycolors <- colorRampPalette(rev(brewer.pal(10,"Spectral")))(21)
mycolors[1] <- "#C0C0C0"
#rasterVis::levelplot(maps,
#                     col.regions = mycolors,
#                     #at = seq(0, 15, 1),
#                     alpha = 0.5,
#                     scales=list(alternating=FALSE),
#                     par.strip.text=list(cex=0),
#                     xlab = NULL, ylab = NULL,
#                     maxpixels = 5e6)
##########################################################################
# Time for bivariate
foot <- raster('~/GitHub/hantaro/data/footprint/wildareas-v3-2009-human-footprint.tif')
memory.limit(20000000000)
foot <- projectRaster(foot, maps[[1]])
foot[foot>50] <- 0
foot <- foot + maps[[1]]*0
# Generate an "all reservoirs" layer
iucn.all <- iucn[iucn$binomial %in% c(known.comp,
pred.comp),]
map.all <- (fasterize(iucn.all, r, fun="sum"))
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}
map.all <- fix(map.all)
map.all <- map.all + foot*0
# Generate the bivariate square
colmat<-function(nquantiles=10, upperleft=rgb(0,150,235, maxColorValue=255), upperright=rgb(130,0,80, maxColorValue=255), bottomleft="grey", bottomright=rgb(255,230,15, maxColorValue=255), xlab="x label", ylab="y label"){
my.data<-seq(0,1,.01)
my.class<-classIntervals(my.data,n=nquantiles,style="quantile")
my.pal.1<-findColours(my.class,c(upperleft,bottomleft))
my.pal.2<-findColours(my.class,c(upperright, bottomright))
col.matrix<-matrix(nrow = 101, ncol = 101, NA)
for(i in 1:101){
my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
col.matrix[102-i,]<-findColours(my.class,my.col)}
plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
for(i in 1:101){
col.temp<-col.matrix[i-1,]
points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}
seqs<-seq(0,100,(100/nquantiles))
seqs[1]<-1
col.matrix<-col.matrix[c(seqs), c(seqs)]}
col.matrix<-colmat(nquantiles=5, upperleft="#be64ac", upperright="#3b4994",
bottomleft="#e8e8e8", bottomright="#5ac8c8",
ylab = "Human footprint", xlab = "Hantavirus reservoirs")
# Generate the bivariate map
bivariate.map<-function(rasterx, rastery, colormatrix=col.matrix, nquantiles=10){
quanmean<-getValues(rasterx)
temp<-data.frame(quanmean, quantile=rep(NA, length(quanmean)))
brks<-with(temp, quantile(unique(temp),na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
r1<-within(temp, quantile <- cut(quanmean, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
quantr<-data.frame(r1[,2])
quanvar<-getValues(rastery)
temp<-data.frame(quanvar, quantile=rep(NA, length(quanvar)))
brks<-with(temp, quantile(unique(temp),na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
r2<-within(temp, quantile <- cut(quanvar, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
quantr2<-data.frame(r2[,2])
as.numeric.factor<-function(x) {as.numeric(levels(x))[x]}
col.matrix2<-colormatrix
cn<-unique(colormatrix)
for(i in 1:length(col.matrix2)){
ifelse(is.na(col.matrix2[i]),col.matrix2[i]<-1,col.matrix2[i]<-which(col.matrix2[i]==cn)[1])}
cols<-numeric(length(quantr[,1]))
for(i in 1:length(quantr[,1])){
a<-as.numeric.factor(quantr[i,1])
b<-as.numeric.factor(quantr2[i,1])
cols[i]<-as.numeric(col.matrix2[b,a])}
r<-rasterx
r[1:length(r)]<-cols
return(r)}
layers <- raster::stack(foot, map.all)
layers <- embarcadero::bigstack(layers, 5)
bivmap<-bivariate.map(layers[[2]], layers[[1]], colormatrix = col.matrix, nquantiles = 5)
plot(bivmap, frame.plot = TRUE, axes = F, box = T, add = F, legend = F, col = as.vector(col.matrix), asp = 1)
map(interior = T, add = T)
iucn.all <- iucn[iucn$binomial %in% c(known.pcr,
pred.pcr),]
map.all <- (fasterize(iucn.all, r, fun="sum"))
fix <- function(x) {sum(x,r,na.rm=TRUE)+r}
map.all <- fix(map.all)
map.all <- map.all + foot*0
# Generate the bivariate square
colmat<-function(nquantiles=10, upperleft=rgb(0,150,235, maxColorValue=255), upperright=rgb(130,0,80, maxColorValue=255), bottomleft="grey", bottomright=rgb(255,230,15, maxColorValue=255), xlab="x label", ylab="y label"){
my.data<-seq(0,1,.01)
my.class<-classIntervals(my.data,n=nquantiles,style="quantile")
my.pal.1<-findColours(my.class,c(upperleft,bottomleft))
my.pal.2<-findColours(my.class,c(upperright, bottomright))
col.matrix<-matrix(nrow = 101, ncol = 101, NA)
for(i in 1:101){
my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
col.matrix[102-i,]<-findColours(my.class,my.col)}
plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
for(i in 1:101){
col.temp<-col.matrix[i-1,]
points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}
seqs<-seq(0,100,(100/nquantiles))
seqs[1]<-1
col.matrix<-col.matrix[c(seqs), c(seqs)]}
col.matrix<-colmat(nquantiles=5, upperleft="#be64ac", upperright="#3b4994",
bottomleft="#e8e8e8", bottomright="#5ac8c8",
ylab = "Human footprint", xlab = "Hantavirus reservoirs")
# Generate the bivariate map
bivariate.map<-function(rasterx, rastery, colormatrix=col.matrix, nquantiles=10){
quanmean<-getValues(rasterx)
temp<-data.frame(quanmean, quantile=rep(NA, length(quanmean)))
brks<-with(temp, quantile(unique(temp),na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
r1<-within(temp, quantile <- cut(quanmean, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
quantr<-data.frame(r1[,2])
quanvar<-getValues(rastery)
temp<-data.frame(quanvar, quantile=rep(NA, length(quanvar)))
brks<-with(temp, quantile(unique(temp),na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
r2<-within(temp, quantile <- cut(quanvar, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
quantr2<-data.frame(r2[,2])
as.numeric.factor<-function(x) {as.numeric(levels(x))[x]}
col.matrix2<-colormatrix
cn<-unique(colormatrix)
for(i in 1:length(col.matrix2)){
ifelse(is.na(col.matrix2[i]),col.matrix2[i]<-1,col.matrix2[i]<-which(col.matrix2[i]==cn)[1])}
cols<-numeric(length(quantr[,1]))
for(i in 1:length(quantr[,1])){
a<-as.numeric.factor(quantr[i,1])
b<-as.numeric.factor(quantr2[i,1])
cols[i]<-as.numeric(col.matrix2[b,a])}
r<-rasterx
r[1:length(r)]<-cols
return(r)}
layers <- raster::stack(foot, map.all)
layers <- embarcadero::bigstack(layers, 5)
bivmap<-bivariate.map(layers[[2]], layers[[1]], colormatrix = col.matrix, nquantiles = 5)
plot(bivmap, frame.plot = TRUE, axes = F, box = T, add = F, legend = F, col = as.vector(col.matrix), asp = 1)
map(interior = T, add = T)
